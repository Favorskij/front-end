
Все => https://angular.io/cli/generate

Название проекта
ng new app-name

Название компонента
ng generate component name-component

Название сервиса
ng generate service name-service

Запуск приложения с ключами
ng serve --port 4201 --open

Название директивы
ng generate directive name-component






npm uninstall -g @angular/cli
npm cache clean --force




////////////////////////////////
////////////////////////////////
////////////////////////////////


{ app.module.ts }
0.  Подключение компонентов к приложению.
    Глобальный импорт в приложение осуществляется в специально для этого TypeScript файле, app.module.ts.

    a) Если мы например импортируем компонент, то, в @NgModule({imports: [], declarations[], bootstrap[]}),
       в массиве declarations:[] мы должны указать этот импортируемый компонент declarations[DataImportExportComponent]

    b) А если мы импортируем например, какой нибудь Angular модуль, то мы указываем его в массиве
       imports:[AppRoutingModule]



{ data-import-export }
1.  Импорт данных из другого файла.
    а) Что бы, что либо импортировать, необходимо на импортируемом элементе указать export, например,
    export const item = 'Привет мир!'

    b) В файле компонента где мы хотим получить экспортируемый объект, необходимо указать путь импорта и название
    самого импортируемого объекта, например, import { item as it } from "./data";. Далее, в этом компонент, мы можем
    обращаться к импортируемой переменной которая в фигурных скобка как к простой переменной.



{ interpolation }
2. Интерполяция {{variable}} переменной в html шаблоне.
   Интерполяция переменной в фигурных скобках html шаблоне это получение значения переменной текущего компонента.
   Так же можно получить не только переменную, но и метод, get, класса


{ broadcast-parent }
{ broadcast-child }
3.1 Передача параметров из родительского компонента в дочерний.


{ for-of-data-parent }
{ for-of-data-child }
3.2 Передача параметров из родительского компонента в дочерний и *ngFor.


{ cast-parent }
{ cast-child }
4.1 Передача параметров из дочернего компонента в родительский


{ voter-parent }
{ voter-child }
4.2. Родитель прослушивает дочернее событие



{ for-of-data }
5. Перебор массива при помощи *ngFor.


{ ng-if-template }
6. ngIf else. Меняем шаблоны.


{ attributes }
7. DOM. Установка в селектор id, style, disabled и другие атрибуты


{ button-click }
8. DOM. Получение события по клику



{ injectable }
9. service. Внедрение зависимостей @Injectable()



{ item-page }
{ item-url }
10.1. router.
    router это создание отдельных страниц. Например, http://www.site.ru/item/1. Каждая страница это один отдельный
    компонент. Чтобы каждая страница могла обрабатываться при помощи router, необходимо в app-routing.module указать
    эти страницы (компоненты).
      Обязательные требования: обязательно, необходимо указывать главную страницу, то есть, одну главную страницу
      которую будет обрабатывать routing. Это первая отображаемая страница при помощи routing.
        Пример: { path: '', component: ItemUrlComponent }. То есть, path необходимо оставлять пустым, это и будет
         главная страница обрабатываемой при помощи routing. А вот component, это component который будет обрабатывать
         данную страницу. Далее указываются следующие адреса { path: 'item/:itemId', component: ItemPageComponent }
         :itemId - это говорит о том, что в этом месте будет генерироваться динамический параметр, например id

    Далее, очень важно понять. Есть такой селектор как <router-outlet></router-outlet>. Собственно в этот селектор
    попадают все адреса которые обрабатывает router. Что бы отобразить страницы которые обрабатывается при помощи
    router, необходимо в том месте, где нужно их отображать, вставить селектор <router-outlet></router-outlet>.

    Когда router замечает что идёт обращение к зарегистрированному адресу, то, router сообщает outlet-у, какой
    компонент необходимо отобразить.


{ item-page }
{ item-url }
10.2. Жизненный цикл OnInit и получаем информацию о товаре по его id
Данный пример полностью скопирован из пункта (10.1. router.) и добавлен небольшой функционал в item-page с
использованием жизненного цикла OnInit. В данном примере мы получаем информацию о товаре по его id при помощи
жизненного цикла OnInit.


{ currency }
11. currency {{ price | currency : 'РУБ ' }}
currency
date
percent
json
number
i18nPlural
keyvalue



{ http-client }
{ http-client.service.ts }
12. HttpClient. Для работы с HttpClient необходимо в app.module.ts в проект импортировать
import { HttpClientModule } from "@angular/common/http";


{ form }
13. forms.
Для работы с формами необходимо в app.module.ts в проект импортировать
import { ReactiveFormsModule } from '@angular/forms';

{ name-parent }
{ name-child }
14. Перехват входных параметров @Input() при помощи get set.


{ version-parent }
{ version-child }
15. Перехватите изменения свойств ввода с помощью жизненного цикла ngOnChanges()


{ countdown-parent-one }
{ countdown-child-one }
16.1 Доступ к дочерним свойствам при помощи локальной переменной #variab



{ input-get }
16.2 Получение данных из #input




{ countdown-parent-two }
{ countdown-child-two }
Более понятный пример показан в пункте 17.2
17.1 Доступ к дочерним свойствам при помощи аннотации @ViewChild()


{ countdown-parent-three }
{ countdown-child-three }
17.2 Доступ к дочерним свойствам при помощи аннотации @ViewChild()



{ service-parent }
{ service-child }
{ message.service.ts }
18. Родитель и дети общаются с помощью сервиса


{{ zippy-basic }}
19. Однослотовая проекция контента


{{ zippy-multislot }}
20. Проекция мультислотового контента


{{ directive }}
{{ directive-id.directive.ts }}
21. Добавление аттрибутов в узел при помощи аннотации @Directive() и @HostBinding()



{{ host-listener }}
{{ @Directive app.component.ts }}
22. Аннотация @HostListener('click')




{{ zippy-template }}
{{ @Directive app.component.ts }}
23. Условное проецирование контента ng-template => TemplateRef, @ContentChild, ng-container, ngTemplateOutlet
https://angular.io/guide/content-projection#conditional-content-projection


{{ ng-project-as }}
24. ngProjectAs Проектирование контента в более сложных средах.
Если зайти в браузере в angular Tools, то можно заметить, что данный узел виртуального дома будет отсутствовать.




{{ ad-banner }}
{{ hero-job-ad }}
{{ hero-profile }}
{{ ad.directive.ts }}
{{ ad.service.ts }}
{{ ad-item.ts }}
{{ ad.component.ts }}

25.1 Dynamic component loader. Динамический загрузчик компонентов. Сложная для понимания версия



{{ dynamic-banner }}
{{ dynamic-profile }}
{{ dynamic.component.ts }}
{{ dynamic.directive.ts }}
{{ dynamicItem.ts }}
25.2 Dynamic component loader. Динамический загрузчик компонентов. Лёгкая для понимания версия




26.1







////////////////
////////////////
////////////////

Заметка:

15. Указание ссылок при помощи routerLink - <a routerLink="/cart">Корзина</a>


16. Работа с конструктором.
Например, если хотим обратиться к полям другого класса, то, это делается через сервис. Например
можно посмотреть в (18. Родитель и дети общаются с помощью сервиса).
Или через директивы



17. {{hasChild ? 'Destroy' : 'Create'}}

https://angular.io/guide/component-interaction#parent-listens-for-child-event


18. Дочерний компонент это, когда в компоненте установлен другой компонент, и, вот этот другой компонент
будет являться дочерним компонентом по отношению к компоненту в который вставлен этот другой компонент.
А компонент в который вставлен другой компонент, будет являться родительским компонентом по отношению
к другому, вставленному компоненту





































6. [title] работает как стандартный title атрибут в html документе: <p title="А вот и я!">Подсказка</p>.
Смотрите изображение assets\title.png.

    Его синтаксис в angular имеет следующий вид:
    <a [title]="items.name + ' Это заголовок объекта'"></a>.
    В параметрах [title]="" можно указывать текст или ссылаться на переменные или всё вместе сразу
    Данный [title] можно привязывать к любому узлу.
    В данном случаи он привязан к узлу <a></a>

Если используется массив *ngFor, то необходимо использовать [title] внутри массива узла что бы применить каждое
значение к каждому объекту
<div *ngFor="">
    <a [title]=""></a>
</div>


7. Условие if = *ngIf
    Отображает данные value если они есть, если данных value нет, то не отображает. Синтаксис следующий:
    <div *ngFor="let items of item">
      <p *ngIf="items.description">
        Description: {{ items.description }}
      </p>
    </div>
    В *ngIf мы проверяем, есть ли там что нибудь, а именно в items.description. Если там ни чего не, то,
    в интерполированных скобках ни чего не отобразится, а если в интерполированных скобках что нибудь есть,
    то мы получи нужное нам значение.

Если используется массив *ngFor, то необходимо использовать [title] внутри массива узла что бы применить каждое
значение к каждому объекту
<div *ngFor="">
  <p *ngIf=""></p>
</div>




 8. Передача данный родительскому компоненту из дочернего.
    Пример с передачей событий.
    Необходимо импортировать метод Output из core для аннотирования переменной.
    Необходимо в дочернем компоненте класса создать переменную и присвоить ей EventEmitter.
    notify = new EventEmitter(); и указать для ней аннотацию @Output().
    @Output() означает выход данных за пределы компонента.

    @Output()
    notify = new EventEmitter();

    Далее. Дак как мы хотим передать событие, и это будет нажатие кнопки, то в узле button нам нужно
    получить это событие, а оно у нас как мы помним в круглых скобках (click)="". Далее. В параметры
    (click)="" мы передаём это событие click. То есть, в параметрах мы вызываем переменную notify
    а это как мы помним notify = new EventEmitter();. То есть, мы вызываем переменную notify и далее методом
    chain (цепочки) вызываем emit и должно получится (click)="notify.emit(). Мы как бы передали это событие
    в Emitter, в эту переменную notify.

    Далее в родительском html компоненте в дочернем селекторе, например в <app-child></app-child> мы вызываем
    метод, а метод называется так, как называется наш EventEmitter в дочернем компоненте класса - notify.
    То есть, мы как бы создали пользовательское событие и теперь мы просто вызываем его как обычный метод событий,
    но так как у нас там лежит событие (click), значит оно будет срабатывать на клике, как и обычный (click). И
    далее уже по стандарту - срабатывает событие и мы можем по событию вызвать какой нибудь метод у родительского
    компонента класса.
    <app-child (notify)="onNotify()" ></app-child>


9. Указание динамической id страницы в пути роутера { path: 'item/:productId', component: ProductDetailsComponent }.
item/:productId - указывает на то, что адрес будет выглядеть следующим образом, например, item/1, где вместо
:productId будет динамически подставляться идентификатор страницы.
Это требуется если необходимо будет получать информацию о товаре по id. То есть, мы можем получить этот id в
компоненте класса и следователь по нему мы можем получить товар.



10. https://angular.io/start/start-routing#view-product-details
Получение информации о товаре. Для того что бы получить информацию о товаре, необходимо получить идентификатор
товара. Что бы получить идентификатор товара, необходимо в роутере указать что будет передаваться динамический
идентификатор для каждого товара. { path: 'item/:productId', component: ProductDetailsComponent }, где :productId
есть динамический идентификатор item/1. Далее. В компоненте класса, где будем получать информацию о товара, необходимо
получить этот идентификатор. Что бы это сделать, нужно импортировать ActivatedRoute из @angular/router и поместить
его в конструктор private route: ActivatedRoute. Далее. В этом же компоненте необходимо в методе ngOnInit(): void {}
получить идентификатор при помощи snapshot и на основе этого идентификатора получить товар и вывести *ngIf его в
html данного компонента.





11. Работа с конструктор. Например, если хотим обратиться к полям другого класса, то, необходимо импортировать
этот класс в текущий класс import { CartService } from '../cart.service';. Далее, в текущем классе
необходимо передать импортируемый класс в конструктор constructor(private cartService: CartService)


12. Чтобы использовать Angular HttpClient, необходимо настроить приложение для использования HttpClientModule.
Angular HttpClientModule регистрирует поставщиков, которые необходимы приложению для использования HttpClient
службы во всем приложении. И что бы это сделать, необходимо в приложение импортировать HttpClientModule из
@angular/common/http. Далее мы можем в приложении в любом месте использовать HttpClient. Для его использования,
мы сделаем следующее, в cart.service.ts мы импортируем import {HttpClient} from "@angular/common/http"; и
поместим в конструктор constructor(private http: HttpClient) и в этом же классе можно использовать эту переменную
http, например создать метод и там использовать
getShippingPrices() {
    return this.http.get<{type: string, price: number}[]>('/assets/shipping.json');
  }
И далее, мы можем работать с этим методом из любого компонента путём импорта. Например, в shipping.component.ts
мы создали переменную shippingCosts и присвоили ей эту вызывающею функцию
shippingCosts = this.cartService.getShippingPrices(); То есть, в переменной shippingCosts у нас теперь
массив данных. И главное, при работе где требуется асинхронность, директиву async необходимо указывать там,
от куда начинает работать этот метод, а именно в html шаблоне. Например, в шаблоне shipping.component.html
<div *ngFor="let shipping of shippingCosts | async">

<div *ngFor="let shipping of shippingCosts | async">
  {{ shipping.type }}
  {{ shipping.price | currency }}
</div>



13. Пример с формой. Например. Первое что нам нужно сделать, это импортировать в проект специальный модуль
ReactiveFormsModule из @angular/forms. Далее, необходимо в классе компоненте где будет использоваться форма,
импортировать FormBuilder и поместить этот FormBuilder в конструктор. Затем необходимо создать переменную, например
checkoutForm и присвоить ей FormBuilder из конструктора. Пример:   checkoutForm = this.formBuilder.group({
                                                                     name: '',
                                                                     address: '',
                                                                   });
this.formBuilder.group({}) содержит в себе объект с полями формы. formBuilder.group() можно очищать
formBuilder.group().reset() и так далее и много разных функций. А вот в самой html форме компонента необходимо
указать следующее - <form [formGroup]="checkoutForm" (ngSubmit)="onSubmit()">
[formGroup] - указывает на то, какую функцию мы будем применять к данной форме. checkoutForm указывает на то,
к какой переменной мы будем присваивать данный функционал. Этим самым мы связываем поля формы и checkoutForm.











https://angular.io/guide/content-projection#single-slot-content-projection
1. Проекция это - если в родительском html шаблоне, в теге дочернего компонента <child><p>Тест</p></child> что нибудь
написать, например, <p>Тест</p> то, это можно спроицировать(отобращить) в дочернем компоненте. Что бы это сделать,
в дочернем html шаблоне необходимо указать тег <ng-content></ng-content>. То есть, все что в родительском html шаблоне,
в теге дочернего компонента <child><p>Тест</p></child> будет указано, это быдет отображено в html шаблоне дочернего
компонента в теге <ng-content></ng-content>


https://angular.io/guide/content-projection#multi-slot-content-projection
2. select. Если в теге <ng-content"></ng-content> указать селектор, например, question, то, в данном теге
<ng-content select="[question]"></ng-content> будет спроицирован (отображён) тот контент, у которого будет указан
селектор question. Например, <child><p question>Тест</p></child>
(Название селектора указывается произвольное)


https://angular.io/guide/content-projection#conditional-content-projection
3. Условное проецирование контента.

